# -*- coding: utf-8 -*-
"""
Finds ThorSync directories corresponding to ThorImage directories
by looking for filenames or a descriptions of pins used in each
presentation, and matching that to the pins the Arduino says it 
uses, decoded from the ThorSync data.

Need to have pin signalled as in my OlfStimDelivery.ino script and 
follow my practice of copying something containing either the 
filename or the full pins to be presented in to the Notes field
in the ThorImage Capture settings.

Created on Wed Mar 15 15:02:09 2017

@author: Tom O'Connell
"""

import os
import shutil
import xml.etree.ElementTree as etree
import ast
import re
import pickle
import tom.odors

# in here should be a directory called 'stimuli'
# which should have pickle files generated by *_odor_randomizer.py
stimuli_base_dir = 'D:/Hong/Tom/stimuli'

thorimage_dir = 'D:/Hong/Tom/flies/tmp_for_unpacking'
thorsync_dir = 'D:/Hong/Tom/flies/tmp_for_unpacking'

valid_fly_ids = re.compile(r'^(\d{6}_\d{2}(?:e|c)?_)')

d = thorimage_dir
image_dirs = [o for o in os.listdir(d) if os.path.isdir(os.path.join(d,o)) \
              and valid_fly_ids.match(o)]

'''
print(os.listdir(d))
print(image_dirs)
s1 = set(os.listdir(d))
s2 = set(image_dirs)
print(s1-s2)
'''

# TODO flag to override assertion errors or to ask y/n instead
# TODO add colors to warnings and green if things pass

# TODO skip any directories already containing ThorSync data

# doesn't actually check for the ../../stimuli/ prefix
# assumes in is in stimuli_base_dir above
stimfile_pattern = re.compile(r'(\d{4}-\d{2}-\d{2}_\d{6}\.p)')

# are angle / square brackets special chars?
#pinlist_re = re.compile(r'\[\{(?:\d\d?(?:, )?)+\}(?:, )?\]+')
pinlist_re = re.compile(r'\[(?:\[(?:\{(?:\d\d?(?:, )?)+\}(?:, )?)+\](?:, )?)+\]')
pin_odor_port_re = re.compile(r'(\d\d?) -> (.* 1e-?\d\d?) -> ([A-Z])')

fly2pl = dict()
fly2ac = dict()
fly2stim = dict()

fly_ids = []

stimfile2imgdir = dict()
without_stimfile = []

for o in image_dirs:
    fly_id = '_'.join(o.split('_')[:2])
    fly_ids.append(fly_id)
    img_dir = os.path.join(d,o)

    expxml = os.path.join(img_dir, 'Experiment.xml')
    notes = etree.parse(expxml).getroot().find('ExperimentNotes').attrib['text']
    stimfile = stimfile_pattern.search(notes)

    # TODO warn if more than one found?
    
    # TODO unit test
    if stimfile is not None:
        #print('stimfile')
        stimfile = os.path.join(stimuli_base_dir, stimfile.group(0))
        stimfile2imgdir[stimfile] = img_dir
        with open(stimfile, 'rb') as f:
            acs_raw, odor_list_raw = pickle.load(f)
            acs_loaded = tuple(tuple(sorted(l, key=lambda x: x[0])) for l in acs_raw)
            odor2pin_list = [{trip[1]: trip[0] for trip in acs} for acs in acs_loaded]
            # TODO convert odorset list to pinset list
            pl_loaded = tuple(tuple(set(d[o] for o in s) for s in l) \
                              for l, d in zip(odor_list_raw, odor2pin_list))
    else:
        acs_loaded = None
        pl_loaded = None
        
        without_stimfile.append(img_dir)
        
        print(fly_id)
        
    # TODO check loaded stuff is consistent with everything else (including order?),
    # and if it is, add it to same dict. directly comparable? tuple?
        
    pl_match = pinlist_re.search(notes)
    pl = None
    
    # TODO check loaded information with parsed information
    if pl_match is not None:
        if pl_loaded is None:
            print('order')
        pl = ast.literal_eval(pl_match.group(0))
        pl = tuple(tuple(l) for l in pl)
        
        # IF WE HAVE DATA FOR THIS SPECIFIC SESSION, this checks that it is 
        # apparently consistent with information from flies with the same id
        if fly_id in fly2pl:
            assert pl == fly2pl[fly_id], 'apparently conflicting list of pins' + \
                ' presented across flies with the same id: ' + fly_id
        else:
            fly2pl[fly_id] = pl
            
        # checks consistency with pin order loaded from pickle file
        # currently will only work if full pin order can be parsed from
        # notes in each session
        if pl_loaded is not None:
            assert pl == pl_loaded, 'pin order loaded from stimulus pickle ' + \
                'file is apparently inconsistent with pin order in notes. ' + \
                fly_id
    
    #elif pl_loaded is not None:
    if pl_loaded is not None:
        # check might be unnecessary
        if fly_id in fly2pl:
            assert pl_loaded == fly2pl[fly_id], 'apparently conflicting ' + \
                'list of pins presented across flies with ' + \
                'the same id (one of which was loaded from pickle): ' + fly_id
        else:
            fly2pl[fly_id] = pl_loaded
    
    # assumes connections will be printed out in a consistent order
    # across all files compared here (to check equality of parsed tuples)
    # also assumes that if there are multiple sets of connections printed, 
    # they are separated by the word 'stoppers' somewhere
    
    # will only use first 3.
    all_connections = [pin_odor_port_re.findall(n) for n in notes.split('stoppers')[:3]]
    
    all_connections = tuple(tuple((int(x[0]), tom.odors.str2pair(x[1]), x[2]) for x in ac) \
                            for ac in all_connections if len(ac) > 0)
    
    # TODO careful. this may break easily
    if len(all_connections) > 1:
        if acs_loaded is None:
            print('connections')

        # IF WE HAVE DATA FOR THIS SPECIFIC SESSION, this checks that it is 
        # apparently consistent with information from flies with the same id
        if fly_id in fly2ac:
            assert all_connections == fly2ac[fly_id], 'apparently conflicting ' + \
                'pin (valve) to odor connections presented across flies with ' + \
                'the same id: ' + fly_id
        else:
            fly2ac[fly_id] = all_connections
            
        if acs_loaded is not None:
            assert all_connections == acs_loaded, 'connections described in notes ' + \
                'are apparently inconsistent with those in stimulus pickle file ' + \
                fly_id + '\n\nnotes:' + str(all_connections) + '\n\nloaded:' + str(acs_loaded)
                
    if acs_loaded is not None:
        # check might be unnecessary
        if fly_id in fly2ac:
            assert acs_loaded == fly2ac[fly_id], 'apparently conflicting ' + \
                'pin (valve) to odor connections presented across flies with ' + \
                'the same id (one of which was loaded from pickle): ' + fly_id
        else:
            fly2ac[fly_id] = acs_loaded

fly_ids = set(fly_ids)
print('Processing fly IDs:')
print(fly_ids)

# TODO warn and include list of things we dont have stimulus for at this point
# mappings and pins separately?
    
# could happen by chance with reasonable probability if you have a really
# small odor panel

# TODO write unit tests for these!!!

# checks the same pin order isn't observed twice in recording
# sessions with different fly_ids (even though not all recordings
# list this)
# would likely indicate a data entry error
for fly in fly2pl:
    copy = dict(fly2pl)
    del copy[fly]
    assert fly2pl.values() != copy.values(), 'possible duplication data entry ' + \
        'error (' + fly + ' and at least one other are involved)'

# checks the same connection pattern isn't observed twice in recording
# sessions with different fly_ids. same reason.
for fly in fly2ac:
    copy = dict(fly2ac)
    del copy[fly]
    assert set(fly2ac.values()) != set(copy.values()), \
        'possible duplication data entry error (' + fly + ' and at least one other are involved)'

assert len(stimfile2imgdir.keys()) == len(stimfile2imgdir.values()), \
    'this should not happen, but dont want to do something dangerous'

# if we have not failed any checks so far, move the stimulus files 
# to their matching ThorImage directories
for sf in stimfile2imgdir:
    dst = stimfile2imgdir[sf]
    assert os.path.isdir(dst)
    # should copy (some?) operating system metadata too
    shutil.copy2(sf, dst)

# TODO generate correct pin 2 odor mappings from notes in available
# save in ThorImage directory as differently named pickle file
# to be read by analysis software
# (parse above, save in imaging dir if all correct)
print('Valve to odor connections and stimulus order pickle file not found for:')
for d in without_stimfile:
    print(d)
print('')



# TODO make sure no two SyncData files decode to the same thing
# ALTHOUGH THIS COULD HAPPEN... MAYBE DONT
# just warn?

# based on ordering of Experiment.xml creation times for a given
# fly ID, match sessions (ID suffix) to pins per presentation list 
# index
# TODO exactly what kind of pickle output do i want to generate?

# for each pickle file, find the ThorSync file that matches that 
# pin presentation ordder after decoding
# TODO could use file creation / mod times to limit search?

# move matching to imaging directories

# if any imaging directories do not appear to have corresponding
# ThorSync data, there is a serious problem that the user needs
# to address

# move non-matching to orphans

